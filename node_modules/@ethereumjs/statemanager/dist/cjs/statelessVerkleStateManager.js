"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatelessVerkleStateManager = void 0;
const rlp_1 = require("@ethereumjs/rlp");
const util_1 = require("@ethereumjs/util");
const verkle_1 = require("@ethereumjs/verkle");
const debug_1 = require("debug");
const keccak_js_1 = require("ethereum-cryptography/keccak.js");
const utils_1 = require("ethereum-cryptography/utils");
const accessWitness_js_1 = require("./accessWitness.js");
const index_js_1 = require("./cache/index.js");
const originalStorageCache_js_1 = require("./cache/originalStorageCache.js");
const { debug: createDebugLogger } = debug_1.default;
const debug = createDebugLogger('statemanager:verkle');
const PUSH_OFFSET = 95;
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const PUSH1 = PUSH_OFFSET + 1;
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const PUSH32 = PUSH_OFFSET + 32;
const ZEROVALUE = '0x0000000000000000000000000000000000000000000000000000000000000000';
/**
 * Stateless Verkle StateManager implementation for the VM.
 *
 * Experimental.
 *
 * This State Manager enables stateless block execution by building a
 * temporary (1-block) state from the verkle block witness.
 * The Stateless Verkle State Manager then uses that populated state
 * to fetch data requested by the the VM.
 *
 */
class StatelessVerkleStateManager {
    /**
     * Instantiate the StateManager interface.
     */
    constructor(opts = {}) {
        /**
         * StateManager is run in DEBUG mode (default: false)
         * Taken from DEBUG environment variable
         *
         * Safeguards on debug() calls are added for
         * performance reasons to avoid string literal evaluation
         * @hidden
         */
        this.DEBUG = false;
        // State along execution (should update)
        this._state = {};
        // Post-state provided from the executionWitness.
        // Should not update. Used for comparing our computed post-state with the canonical one.
        this._postState = {};
        // Checkpointing
        this._checkpoints = [];
        this.originalStorageCache = new originalStorageCache_js_1.OriginalStorageCache(this.getContractStorage.bind(this));
        this._accountCacheSettings = {
            deactivate: opts.accountCacheOpts?.deactivate ?? false,
            type: opts.accountCacheOpts?.type ?? index_js_1.CacheType.ORDERED_MAP,
            size: opts.accountCacheOpts?.size ?? 100000,
        };
        if (!this._accountCacheSettings.deactivate) {
            this._accountCache = new index_js_1.AccountCache({
                size: this._accountCacheSettings.size,
                type: this._accountCacheSettings.type,
            });
        }
        this._storageCacheSettings = {
            deactivate: opts.storageCacheOpts?.deactivate ?? false,
            type: opts.storageCacheOpts?.type ?? index_js_1.CacheType.ORDERED_MAP,
            size: opts.storageCacheOpts?.size ?? 20000,
        };
        if (!this._storageCacheSettings.deactivate) {
            this._storageCache = new index_js_1.StorageCache({
                size: this._storageCacheSettings.size,
                type: this._storageCacheSettings.type,
            });
        }
        this._codeCacheSettings = {
            deactivate: (opts.codeCacheOpts?.deactivate === true || opts.codeCacheOpts?.size === 0) ?? false,
            type: opts.codeCacheOpts?.type ?? index_js_1.CacheType.ORDERED_MAP,
            size: opts.codeCacheOpts?.size ?? 20000,
        };
        if (!this._codeCacheSettings.deactivate) {
            this._codeCache = new index_js_1.CodeCache({
                size: this._codeCacheSettings.size,
                type: this._codeCacheSettings.type,
            });
        }
        this.keccakFunction = opts.common?.customCrypto.keccak256 ?? keccak_js_1.keccak256;
        // Skip DEBUG calls unless 'ethjs' included in environmental DEBUG variables
        // Additional window check is to prevent vite browser bundling (and potentially other) to break
        this.DEBUG =
            typeof window === 'undefined' ? process?.env?.DEBUG?.includes('ethjs') ?? false : false;
        /*
         * For a custom StateManager implementation adopt these
         * callbacks passed to the `Cache` instantiated to perform
         * the `get`, `put` and `delete` operations with the
         * desired backend.
         */
        // const getCb: get = async (address) => {
        //   return undefined
        // }
        // const putCb: put = async (keyBuf, accountRlp) => {}
        // const deleteCb = async (keyBuf: Uint8Array) => {}
        // this._cache = new Cache({ get, putCb, deleteCb })
    }
    async getTransitionStateRoot(_, __) {
        throw Error('not implemented');
    }
    initVerkleExecutionWitness(executionWitness, accessWitness) {
        if (executionWitness === null || executionWitness === undefined) {
            throw Error(`Invalid executionWitness=${executionWitness} for initVerkleExecutionWitness`);
        }
        this._executionWitness = executionWitness;
        this.accessWitness = accessWitness ?? new accessWitness_js_1.AccessWitness();
        this._proof = executionWitness.verkleProof;
        // Populate the pre-state and post-state from the executionWitness
        const preStateRaw = executionWitness.stateDiff.flatMap(({ stem, suffixDiffs }) => {
            const suffixDiffPairs = suffixDiffs.map(({ currentValue, suffix }) => {
                const key = `${stem}${(0, util_1.padToEven)(Number(suffix).toString(16))}`;
                return {
                    [key]: currentValue,
                };
            });
            return suffixDiffPairs;
        });
        const preState = preStateRaw.reduce((prevValue, currentValue) => {
            const acc = { ...prevValue, ...currentValue };
            return acc;
        }, {});
        this._state = preState;
        const postStateRaw = executionWitness.stateDiff.flatMap(({ stem, suffixDiffs }) => {
            const suffixDiffPairs = suffixDiffs.map(({ newValue, suffix }) => {
                const key = `${stem}${(0, util_1.padToEven)(Number(suffix).toString(16))}`;
                // A postState value of null means there was no change from the preState.
                // In this implementation, we therefore replace null with the preState.
                const value = newValue ?? this._state[key];
                return {
                    [key]: value,
                };
            });
            return suffixDiffPairs;
        });
        const postState = postStateRaw.reduce((prevValue, currentValue) => {
            const acc = { ...prevValue, ...currentValue };
            return acc;
        }, {});
        this._postState = postState;
        debug('initVerkleExecutionWitness preState', this._state);
        debug('initVerkleExecutionWitness postState', this._postState);
    }
    getTreeKeyForVersion(stem) {
        return (0, verkle_1.getKey)(stem, accessWitness_js_1.VERSION_LEAF_KEY);
    }
    getTreeKeyForBalance(stem) {
        return (0, verkle_1.getKey)(stem, accessWitness_js_1.BALANCE_LEAF_KEY);
    }
    getTreeKeyForNonce(stem) {
        return (0, verkle_1.getKey)(stem, accessWitness_js_1.NONCE_LEAF_KEY);
    }
    getTreeKeyForCodeHash(stem) {
        return (0, verkle_1.getKey)(stem, accessWitness_js_1.CODE_KECCAK_LEAF_KEY);
    }
    getTreeKeyForCodeSize(stem) {
        return (0, verkle_1.getKey)(stem, accessWitness_js_1.CODE_SIZE_LEAF_KEY);
    }
    getTreeKeyForCodeChunk(address, chunkId) {
        const { treeIndex, subIndex } = (0, accessWitness_js_1.getTreeIndicesForCodeChunk)(chunkId);
        return (0, verkle_1.getKey)((0, verkle_1.getStem)(address, treeIndex), (0, util_1.toBytes)(subIndex));
    }
    chunkifyCode(code) {
        // Pad code to multiple of 31 bytes
        if (code.length % 31 !== 0) {
            const paddingLength = 31 - (code.length % 31);
            code = (0, util_1.setLengthRight)(code, code.length + paddingLength);
        }
        throw new Error('Not implemented');
    }
    getTreeKeyForStorageSlot(address, storageKey) {
        const { treeIndex, subIndex } = (0, accessWitness_js_1.getTreeIndexesForStorageSlot)(storageKey);
        return (0, verkle_1.getKey)((0, verkle_1.getStem)(address, treeIndex), (0, util_1.toBytes)(subIndex));
    }
    checkChunkWitnessPresent(address, codeOffset) {
        const chunkId = codeOffset / 31;
        const chunkKey = (0, util_1.bytesToHex)(this.getTreeKeyForCodeChunk(address, chunkId));
        return this._state[chunkKey] !== undefined;
    }
    /**
     * Copies the current instance of the `StateManager`
     * at the last fully committed point, i.e. as if all current
     * checkpoints were reverted.
     */
    shallowCopy() {
        const stateManager = new StatelessVerkleStateManager();
        stateManager.initVerkleExecutionWitness(this._executionWitness);
        return stateManager;
    }
    /**
     * Adds `value` to the state trie as code, and sets `codeHash` on the account
     * corresponding to `address` to reference this.
     * @param address - Address of the `account` to add the `code` for
     * @param value - The value of the `code`
     */
    async putContractCode(address, value) {
        if (this.DEBUG) {
            debug(`putContractCode address=${address.toString()} value=${(0, util_1.short)(value)}`);
        }
        this._codeCache?.put(address, value);
        const codeHash = (0, keccak_js_1.keccak256)(value);
        if (util_1.KECCAK256_NULL === codeHash) {
            // If the code hash is the null hash, no code has to be stored
            return;
        }
        if ((await this.getAccount(address)) === undefined) {
            await this.putAccount(address, new util_1.Account());
        }
        await this.modifyAccountFields(address, { codeHash });
    }
    /**
     * Gets the code corresponding to the provided `address`.
     * @param address - Address to get the `code` for
     * @returns {Promise<Uint8Array>} -  Resolves with the code corresponding to the provided address.
     * Returns an empty `Uint8Array` if the account has no associated code.
     */
    async getContractCode(address) {
        if (this.DEBUG) {
            debug(`getContractCode address=${address.toString()}`);
        }
        if (!this._codeCacheSettings.deactivate) {
            const elem = this._codeCache?.get(address);
            if (elem !== undefined) {
                return elem.code ?? new Uint8Array(0);
            }
        }
        const account = await this.getAccount(address);
        if (!account) {
            return new Uint8Array(0);
        }
        if (!account.isContract()) {
            return new Uint8Array(0);
        }
        // Get the contract code size
        const codeSizeKey = this.getTreeKeyForCodeSize((0, verkle_1.getStem)(address, 0));
        const codeSizeLE = (0, util_1.hexToBytes)(this._state[(0, util_1.bytesToHex)(codeSizeKey)] ?? '0x');
        const codeSize = (0, util_1.bytesToInt32)(codeSizeLE, true);
        // allocate the code and copy onto it from the available witness chunks
        const accessedCode = new Uint8Array(codeSize);
        const chunks = Math.floor((0, util_1.bytesToInt32)(codeSizeLE, true) / 31);
        for (let chunkId = 0; chunkId <= chunks; chunkId++) {
            const chunkKey = (0, util_1.bytesToHex)(this.getTreeKeyForCodeChunk(address, chunkId));
            const codeChunk = this._state[chunkKey];
            if (codeChunk === undefined) {
                throw Error(`Invalid access to a missing code chunk with chunkKey=${chunkKey}`);
            }
            if (codeChunk === null) {
                throw Error(`Invalid access to a non existent code chunk with chunkKey=${chunkKey}`);
            }
            const codeOffset = chunkId * 31;
            // if code chunk was accessed as per the provided witnesses copy it over
            if (codeChunk !== undefined) {
                // actual code starts from index 1 in chunk, 0th index is if there are any push data bytes
                const actualChunk = (0, util_1.hexToBytes)(codeChunk).slice(1);
                accessedCode.set(actualChunk, codeOffset);
            }
            else {
                // else fill this unaccessed segment with invalid opcode since the evm execution shouldn't
                // end up here
                accessedCode.fill(0xfe, codeOffset, 31);
            }
        }
        // Return accessedCode where only accessed code has been copied
        return accessedCode;
    }
    /**
     * Gets the storage value associated with the provided `address` and `key`. This method returns
     * the shortest representation of the stored value.
     * @param address -  Address of the account to get the storage for
     * @param key - Key in the account's storage to get the value for. Must be 32 bytes long.
     * @returns {Promise<Uint8Array>} - The storage value for the account
     * corresponding to the provided address at the provided key.
     * If this does not exist an empty `Uint8Array` is returned.
     */
    async getContractStorage(address, key) {
        if (!this._storageCacheSettings.deactivate) {
            const value = this._storageCache.get(address, key);
            if (value !== undefined) {
                return value;
            }
        }
        const storageKey = this.getTreeKeyForStorageSlot(address, BigInt((0, util_1.bytesToHex)(key)));
        const storageValue = (0, util_1.toBytes)(this._state[(0, util_1.bytesToHex)(storageKey)]);
        if (!this._storageCacheSettings.deactivate) {
            this._storageCache?.put(address, key, storageValue ?? (0, util_1.hexToBytes)('0x80'));
        }
        return storageValue;
    }
    /**
     * Adds value to the state for the `account`
     * corresponding to `address` at the provided `key`.
     * @param address -  Address to set a storage value for
     * @param key - Key to set the value at. Must be 32 bytes long.
     * @param value - Value to set at `key` for account corresponding to `address`. Cannot be more than 32 bytes. Leading zeros are stripped. If it is a empty or filled with zeros, deletes the value.
     */
    async putContractStorage(address, key, value) {
        if (!this._storageCacheSettings.deactivate) {
            const encodedValue = rlp_1.RLP.encode(value);
            this._storageCache.put(address, key, encodedValue);
        }
        else {
            // TODO: Consider refactoring this in a writeContractStorage function? Like in stateManager.ts
            const storageKey = this.getTreeKeyForStorageSlot(address, BigInt((0, util_1.bytesToHex)(key)));
            this._state[(0, util_1.bytesToHex)(storageKey)] = (0, util_1.bytesToHex)((0, util_1.setLengthRight)(value, 32));
        }
    }
    /**
     * Clears all storage entries for the account corresponding to `address`.
     * @param address -  Address to clear the storage of
     */
    async clearContractStorage(address) {
        const stem = (0, verkle_1.getStem)(address, 0);
        const codeHashKey = this.getTreeKeyForCodeHash(stem);
        this._storageCache?.clearContractStorage(address);
        // Update codeHash to `c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470`
        this._state[(0, util_1.bytesToHex)(codeHashKey)] = util_1.KECCAK256_NULL_S;
        // TODO: Clear all storage slots (how?)
    }
    async getAccount(address) {
        if (!this._accountCacheSettings.deactivate) {
            const elem = this._accountCache.get(address);
            if (elem !== undefined) {
                return elem.accountRLP !== undefined
                    ? util_1.Account.fromRlpSerializedAccount(elem.accountRLP)
                    : undefined;
            }
        }
        const stem = (0, verkle_1.getStem)(address, 0);
        const versionKey = this.getTreeKeyForVersion(stem);
        const versionChunk = this._state[(0, util_1.bytesToHex)(versionKey)];
        if (versionChunk === undefined) {
            throw Error(`Missing execution witness for address=${address} versionKey=${(0, util_1.bytesToHex)(versionKey)}`);
        }
        // if the versionChunk is null it means the account doesn't exist in pre state
        if (versionChunk === null) {
            return undefined;
        }
        const balanceKey = this.getTreeKeyForBalance(stem);
        const nonceKey = this.getTreeKeyForNonce(stem);
        const codeHashKey = this.getTreeKeyForCodeHash(stem);
        const balanceRaw = this._state[(0, util_1.bytesToHex)(balanceKey)];
        const nonceRaw = this._state[(0, util_1.bytesToHex)(nonceKey)];
        const codeHashRaw = this._state[(0, util_1.bytesToHex)(codeHashKey)];
        const account = util_1.Account.fromAccountData({
            balance: typeof balanceRaw === 'string' ? (0, util_1.bytesToBigInt)((0, util_1.hexToBytes)(balanceRaw), true) : undefined,
            nonce: typeof nonceRaw === 'string' ? (0, util_1.bytesToBigInt)((0, util_1.hexToBytes)(nonceRaw), true) : undefined,
            codeHash: codeHashRaw?.length === 32 ? codeHashRaw : util_1.KECCAK256_NULL_S,
        });
        if (this.DEBUG) {
            debug(`getAccount address=${address.toString()} stem=${(0, util_1.short)(stem)} balance=${account.balance} nonce=${account.nonce} codeHash=${(0, util_1.short)(account.codeHash)} storageHash=${(0, util_1.short)(account.storageRoot)}`);
        }
        if (!this._accountCacheSettings.deactivate) {
            this._accountCache?.put(address, account);
        }
        return account;
    }
    async putAccount(address, account) {
        if (this.DEBUG) {
            debug(`putAccount address=${address.toString()} balance=${account.balance} nonce=${account.nonce} codeHash=${(0, util_1.short)(account.codeHash)} storageHash=${(0, util_1.short)(account.storageRoot)}`);
        }
        if (this._accountCacheSettings.deactivate) {
            const stem = (0, verkle_1.getStem)(address, 0);
            const balanceKey = this.getTreeKeyForBalance(stem);
            const nonceKey = this.getTreeKeyForNonce(stem);
            const codeHashKey = this.getTreeKeyForCodeHash(stem);
            const balanceBuf = (0, util_1.setLengthRight)((0, util_1.bigIntToBytes)(account.balance, true), 32);
            const nonceBuf = (0, util_1.setLengthRight)((0, util_1.bigIntToBytes)(account.nonce, true), 32);
            this._state[(0, util_1.bytesToHex)(balanceKey)] = (0, util_1.bytesToHex)(balanceBuf);
            this._state[(0, util_1.bytesToHex)(nonceKey)] = (0, util_1.bytesToHex)(nonceBuf);
            this._state[(0, util_1.bytesToHex)(codeHashKey)] = (0, util_1.bytesToHex)(account.codeHash);
        }
        else {
            if (account !== undefined) {
                this._accountCache.put(address, account);
            }
            else {
                this._accountCache.del(address);
            }
        }
    }
    /**
     * Deletes an account from state under the provided `address`.
     * @param address - Address of the account which should be deleted
     */
    async deleteAccount(address) {
        if (this.DEBUG) {
            debug(`Delete account ${address}`);
        }
        this._codeCache?.del(address);
        this._accountCache.del(address);
        if (!this._storageCacheSettings.deactivate) {
            this._storageCache?.clearContractStorage(address);
        }
    }
    async modifyAccountFields(address, accountFields) {
        let account = await this.getAccount(address);
        if (!account) {
            account = new util_1.Account();
        }
        account.nonce = accountFields.nonce ?? account.nonce;
        account.balance = accountFields.balance ?? account.balance;
        account.storageRoot = accountFields.storageRoot ?? account.storageRoot;
        account.codeHash = accountFields.codeHash ?? account.codeHash;
        await this.putAccount(address, account);
    }
    getProof(_, __ = []) {
        throw new Error('Not implemented yet');
    }
    async verifyProof(parentVerkleRoot) {
        // Implementation: https://github.com/crate-crypto/rust-verkle-wasm/blob/master/src/lib.rs#L45
        // The root is the root of the current (un-updated) trie
        // The proof is proof of membership of all of the accessed values
        // keys_values is a map from the key of the accessed value to a tuple
        // the tuple contains the old value and the updated value
        //
        // This function returns the new root when all of the updated values are applied
        const updatedStateRoot = (0, verkle_1.verifyUpdate)(parentVerkleRoot, this._proof, // TODO: Convert this into a Uint8Array ingestible by the method
        new Map() // TODO: Generate the keys_values map from the old to the updated value
        );
        // TODO: Not sure if this should return the updated state Root (current block) or the un-updated one (parent block)
        const verkleRoot = await this.getStateRoot();
        // Verify that updatedStateRoot matches the state root of the block
        return (0, utils_1.equalsBytes)(updatedStateRoot, verkleRoot);
    }
    // Verifies that the witness post-state matches the computed post-state
    verifyPostState() {
        // track what all chunks were accessed so as to compare in the end if any chunks were missed
        // in access while comparising against the provided poststate in the execution witness
        const accessedChunks = new Map();
        // switch to false if postVerify fails
        let postVerified = true;
        for (const accessedState of this.accessWitness.accesses()) {
            const { address, type } = accessedState;
            let extraMeta = '';
            if (accessedState.type === accessWitness_js_1.AccessedStateType.Code) {
                extraMeta = `codeOffset=${accessedState.codeOffset}`;
            }
            else if (accessedState.type === accessWitness_js_1.AccessedStateType.Storage) {
                extraMeta = `slot=${accessedState.slot}`;
            }
            const { chunkKey } = accessedState;
            accessedChunks.set(chunkKey, true);
            let computedValue = this.getComputedValue(accessedState);
            let canonicalValue = this._postState[chunkKey];
            if (canonicalValue === undefined) {
                debug(`Block accesses missing in canonical address=${address} type=${type} ${extraMeta} chunkKey=${chunkKey}`);
                postVerified = false;
                continue;
            }
            // if the access type is code, then we can't match the first byte because since the computed value
            // doesn't has the first byte for push data since previous chunk code itself might not be available
            if (accessedState.type === accessWitness_js_1.AccessedStateType.Code) {
                computedValue = computedValue !== null ? `0x${computedValue.slice(4)}` : null;
                canonicalValue = canonicalValue !== null ? `0x${canonicalValue.slice(4)}` : null;
            }
            if (computedValue !== canonicalValue) {
                const decodedComputedValue = (0, accessWitness_js_1.decodeValue)(accessedState.type, computedValue);
                const decodedCanonicalValue = (0, accessWitness_js_1.decodeValue)(accessedState.type, canonicalValue);
                const displayComputedValue = computedValue === decodedComputedValue
                    ? computedValue
                    : `${computedValue} (${decodedComputedValue})`;
                const displayCanonicalValue = canonicalValue === decodedCanonicalValue
                    ? canonicalValue
                    : `${canonicalValue} (${decodedCanonicalValue})`;
                debug(`Block accesses mismatch address=${address} type=${type} ${extraMeta} chunkKey=${chunkKey}`);
                debug(`expected=${displayCanonicalValue}`);
                debug(`computed=${displayComputedValue}`);
                postVerified = false;
            }
        }
        for (const canChunkKey of Object.keys(this._postState)) {
            if (accessedChunks.get(canChunkKey) === undefined) {
                debug(`Missing chunk access for canChunkKey=${canChunkKey}`);
                postVerified = false;
            }
        }
        debug(`verifyPostState=${postVerified}`);
        return postVerified;
    }
    getComputedValue(accessedState) {
        const { address, type } = accessedState;
        switch (type) {
            case accessWitness_js_1.AccessedStateType.Version: {
                const encodedAccount = this._accountCache?.get(address)?.accountRLP;
                if (encodedAccount === undefined) {
                    return null;
                }
                // Version is always 0
                // TODO: Update this when versioning is added to accounts
                return ZEROVALUE;
            }
            case accessWitness_js_1.AccessedStateType.Balance: {
                const encodedAccount = this._accountCache?.get(address)?.accountRLP;
                if (encodedAccount === undefined) {
                    return null;
                }
                const balanceBigint = util_1.Account.fromRlpSerializedAccount(encodedAccount).balance;
                return (0, util_1.bytesToHex)((0, util_1.setLengthRight)((0, util_1.bigIntToBytes)(balanceBigint, true), 32));
            }
            case accessWitness_js_1.AccessedStateType.Nonce: {
                const encodedAccount = this._accountCache?.get(address)?.accountRLP;
                if (encodedAccount === undefined) {
                    return null;
                }
                const nonceBigint = util_1.Account.fromRlpSerializedAccount(encodedAccount).nonce;
                return (0, util_1.bytesToHex)((0, util_1.setLengthRight)((0, util_1.bigIntToBytes)(nonceBigint, true), 32));
            }
            case accessWitness_js_1.AccessedStateType.CodeHash: {
                const encodedAccount = this._accountCache?.get(address)?.accountRLP;
                if (encodedAccount === undefined) {
                    return null;
                }
                return (0, util_1.bytesToHex)(util_1.Account.fromRlpSerializedAccount(encodedAccount).codeHash);
            }
            case accessWitness_js_1.AccessedStateType.CodeSize: {
                const codeSize = this._codeCache?.get(address)?.code?.length;
                if (codeSize === undefined) {
                    // it could be an EOA lets check for that
                    const encodedAccount = this._accountCache?.get(address)?.accountRLP;
                    if (encodedAccount === undefined) {
                        return null;
                    }
                    const account = util_1.Account.fromRlpSerializedAccount(encodedAccount);
                    if (account.isContract()) {
                        throw Error(`Code cache not found for address=${address.toString()}`);
                    }
                    else {
                        return null;
                    }
                }
                return (0, util_1.bytesToHex)((0, util_1.setLengthRight)((0, util_1.bigIntToBytes)(BigInt(codeSize), true), 32));
            }
            case accessWitness_js_1.AccessedStateType.Code: {
                const { codeOffset } = accessedState;
                const code = this._codeCache?.get(address)?.code;
                if (code === undefined) {
                    return null;
                }
                // we can only compare the actual code because to compare the first byte would
                // be very tricky and impossible in certain scenarios like when the previous code chunk
                // was not accessed and hence not even provided in the witness
                const chunkSize = 31;
                return (0, util_1.bytesToHex)(code.slice(codeOffset, codeOffset + chunkSize));
            }
            case accessWitness_js_1.AccessedStateType.Storage: {
                const { slot } = accessedState;
                const storage = this._storageCache?.get(address, (0, util_1.bigIntToBytes)(slot));
                if (storage === undefined) {
                    return null;
                }
                return (0, util_1.bytesToHex)(storage);
            }
        }
    }
    /**
     * Checkpoints the current state of the StateManager instance.
     * State changes that follow can then be committed by calling
     * `commit` or `reverted` by calling rollback.
     */
    async checkpoint() {
        this._checkpoints.push(this._state);
        this._accountCache?.checkpoint();
        this._storageCache?.checkpoint();
        this._codeCache?.checkpoint();
    }
    /**
     * Commits the current change-set to the instance since the
     * last call to checkpoint.
     */
    async commit() {
        this._checkpoints.pop();
        this._accountCache.commit();
        this._storageCache?.commit();
        this._codeCache?.commit();
    }
    // TODO
    async hasStateRoot(_) {
        return true;
    }
    /**
     * Reverts the current change-set to the instance since the
     * last call to checkpoint.
     */
    async revert() {
        // setup trie checkpointing
        this._checkpoints.pop();
        this._accountCache?.revert();
        this._storageCache?.revert();
        this._codeCache?.revert();
    }
    /**
     * Writes all cache items to the trie
     */
    async flush() { }
    /**
     * Gets the verkle root.
     * NOTE: this needs some examination in the code where this is needed
     * and if we have the verkle root present
     * @returns {Promise<Uint8Array>} - Returns the verkle root of the `StateManager`
     */
    async getStateRoot() {
        return new Uint8Array(0);
    }
    /**
     * TODO: needed?
     * Maybe in this context: reset to original pre state suffice
     * @param stateRoot - The verkle root to reset the instance to
     */
    async setStateRoot(_) { }
    /**
     * Dumps the RLP-encoded storage values for an `account` specified by `address`.
     * @param address - The address of the `account` to return storage for
     * @returns {Promise<StorageDump>} - The state of the account as an `Object` map.
     * Keys are are the storage keys, values are the storage values as strings.
     * Both are represented as hex strings without the `0x` prefix.
     */
    async dumpStorage(_) {
        throw Error('not implemented');
    }
    dumpStorageRange(_, __, ___) {
        throw Error('not implemented');
    }
    /**
     * Clears all underlying caches
     */
    clearCaches() {
        this._accountCache?.clear();
        this._codeCache?.clear();
        this._storageCache?.clear();
    }
    generateCanonicalGenesis(_initState) {
        return Promise.resolve();
    }
    getAppliedKey(_) {
        throw Error('not implemented');
    }
}
exports.StatelessVerkleStateManager = StatelessVerkleStateManager;
//# sourceMappingURL=statelessVerkleStateManager.js.map